{"meta":{"title":"petertan303","subtitle":"welcome？","description":"","author":"peter？","url":"http://Petertan303.github.io","root":"/"},"pages":[{"title":"about","date":"2023-01-16T14:00:14.000Z","updated":"2023-04-19T12:05:30.369Z","comments":false,"path":"about/index.html","permalink":"http://petertan303.github.io/about/index.html","excerpt":"","text":"你好，世界。 你好，陌生人。"}],"posts":[{"title":"2023年4月19日","slug":"2023年4月19日","date":"2023-04-19T11:07:00.000Z","updated":"2023-04-19T12:06:53.252Z","comments":true,"path":"2023/04/19/2023年4月19日/","link":"","permalink":"http://petertan303.github.io/2023/04/19/2023%E5%B9%B44%E6%9C%8819%E6%97%A5/","excerpt":"","text":"亲爱的日记：关于vits前几天发现了autodl这个GPU租用平台，于是充了15块钱，拿来跑vits。 至于原因，我之前一直觉得，自家电脑环境有问题、显存也不够，不足以支撑运算。于是租了三块，每块用多少扣多少钱，一个小时0.78元，可以说是相当便宜。 刚刚回忆了一下，之前监控的内存占用，是不是只有2G多，还有快到离谱（训练一分钟歌曲只需要零点几秒）的速度，又想起还有conda这个环境管理器，于是在自己电脑上试了试。 事实证明，能跑，而且，对显存要求很低。大概只占用了1G多。虽然确实慢了不少，78秒的音频文件，使用了61秒跑完。尽管确实很慢，但比我想象中还是快太多了。 这下不需要忧心忡忡等GPu空闲了。也不需要开着filezilla等着文件传输的完成。更不需要熄灯后用手机热点慢慢传数据了。 但是训练模型，应该还是需要更牛逼的GPU来干。 关于spleeter这是一个分割音频中人声、伴奏的开源工程，只有11M左右。GUI版本甚至更小，只有10M。 我正在试图解读。 还是关于vitsvits和so-vits-svc有本质区别，虽然我把这俩混为一谈。vits，很小，只有14m；so-vits-svc，更小，小的超乎想象，只有9m。 但是事实上这俩确实是两码事。vits比较大可能是因为自带了测试样品。 so-vits-svc，SoftVC VITS Singing Voice Conversion。 vits，VITS，Conditional Variational Autoencoder with Adversarial Learning for End-to-End Text-to-Speech。 这是VITS的论文。 https://arxiv.org/abs/2106.06103 https://petertan303.github.io/img/2106.06103.pdf 关于hexo博客插入pdf在线预览https://lizhening.github.io/posts/7d20ce7f/ 简单概括就是： hexo-pdf插件。通过npm安装，注意是在hexo根目录下执行该语句。npm install --save hexo-pdf &#123;% pdf 链接 %&#125;的形式插入即可，例如&#123;% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %&#125; 那么，我这个就是: 另外注意pdf可以直接放在source文件夹里面。似乎并不可以……还是放在img文件夹里得了。 好吧，还是有点问题。","categories":[],"tags":[]},{"title":"关于香橙派显示屏","slug":"关于香橙派显示屏","date":"2023-04-11T10:33:01.000Z","updated":"2023-04-12T05:56:51.963Z","comments":true,"path":"2023/04/11/关于香橙派显示屏/","link":"","permalink":"http://petertan303.github.io/2023/04/11/%E5%85%B3%E4%BA%8E%E9%A6%99%E6%A9%99%E6%B4%BE%E6%98%BE%E7%A4%BA%E5%B1%8F/","excerpt":"","text":"香橙派店家资料LCD 显示屏和开发板的接线方式如下所示 对应到手头的显示屏 TFT SPI 模块引脚 开发板26pin 对应的引脚 GPIO – GPIO num 3.3v VCC 1 号引脚 GND GND 6 号引脚 T_CS CS 24 号引脚 RST RESET 7 号引脚 PC9 – 73 AO(LCD_RS) D&#x2F;C 11 号引脚 PC6 – 70 MOSI&#x2F;SDI SDI(MOSI) 19 号引脚 SDK SCK 23 号引脚 ? LED 13 号引脚 PC5 – 69 MISO SDO(MISO) 21 引脚 显示屏店家资料 解释 16 14 12 10 8 6 4 2 电路板 T_CLK NC MOSI NC CS SCK NC GND 原理图 T_CLK - T_MOSI - LCD_CS LCD_SCL - GND 解释 时钟？ - 输入 - 片选信号 时钟信号 - 地 - 17 15 13 11 9 7 5 3 电路板 T_CS PEN MISO SDI AO RST BL 3.3V 原理图 T_CS T_PEN T_MISO LCD_SDI LCD_RS LCD_RST IO_BK 3.3v 解释 片选信号 ？ 输出 传递数据 命令&#x2F;数据 重置 ？ 电源 一般来说是标准七脚，分别是GND，VCC，D0，D1，RES，DC，CS GND：接地 VCC：供电 DO：Master input slave output，MISO， DI：Master output slave input，MOSI， RES：RST，复位 DC：RS，在只有MOSI的情况下控制写入数据还是命令，这个时候没有MISO CS：CE，SSEL，SS，片选信号 SCLK：时钟信号 放在这块显示屏上，则是 GND：接地 VCC：供电 DO：T_MISO DI：T_MOSI，LCD_SDI RES：LCD_RST DC：LCD_RS CS：T_CS SCLK：T_CLK，LCD_SCL 公用的有 GND 3.3v IO_BK LCD开头的有 LCD_CS LCD_SCL（CLK） LCD_SDI（MOSI） LCD_RS LCD_RST T开头的有 T_CLK T_MOSI T_MISO T_CS T_PEN 公用三个，T开头LCD开头各五个，共计16个，三个NC 基本参数： 240 X RGB X 320 驱动：fb_ili9341 使用ssh传输文件：123scp root@192.168.3.29:/boot/boot.bmp .scp &quot;burythelight2 (online-audio-converter.com).rar&quot; root@192.168.3.29:/.","categories":[],"tags":[]},{"title":"嵌入式操作系统","slug":"嵌入式操作系统","date":"2023-04-11T09:13:57.000Z","updated":"2023-04-11T23:58:20.592Z","comments":true,"path":"2023/04/11/嵌入式操作系统/","link":"","permalink":"http://petertan303.github.io/2023/04/11/%E5%B5%8C%E5%85%A5%E5%BC%8F%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"现有嵌入式操作系统Mobile operating systems DIP DOS on Atari Portfolio Embedded Linux (see also Linux for mobile devices) Android CalyxOS DivestOS EMUI Flyme OS GrapheneOS LineageOS MIUI Replicant See also List of custom Android distributions Firefox OS KaiOS Ångström distribution Familiar Linux Mæmo based on Debian deployed on Nokia’s Nokia 770, N800 and N810 Internet Tablets. OpenZaurus webOS from Palm, Inc., later Hewlett-Packard via acquisition, and most recently at LG Electronics through acquisition from Hewlett-Packard[39] Access Linux Platform bada Openmoko Linux OPhone MeeGo (from merger of Maemo &amp; Moblin) Mobilinux MotoMagx Qt Extended Sailfish OS Tizen (earlier called LiMo Platform) Ubuntu Touch PostmarketOS Inferno (distributed OS originally from Bell Labs) Magic Cap MS-DOS on Poqet PC, HP 95LX, HP 100LX, HP 200LX, HP 1000CX, HP OmniGo 700LX NetBSD Newton OS on Apple MessagePad Palm OS from Palm, Inc; now spun off as PalmSource PEN&#x2F;GEOS on HP OmniGo 100 and 120 PenPoint OS Plan 9 from Bell Labs PVOS Symbian OS EPOC Windows CE, from Microsoft Pocket PC from Microsoft, a variant of Windows CE Windows Mobile from Microsoft, a variant of Windows CE Windows Phone from Microsoft DSPnano RTOS iOS watchOS tvOS iPod software iPodLinux iriver clix OS RockBox BlackBerry OS PEN&#x2F;GEOS, GEOS-SC, GEOS-SE Palm OS Symbian platform (successor to Symbian OS) BlackBerry 10 HarmonyOS - Routers CatOS – by Cisco Systems Cisco IOS – originally Internetwork Operating System by Cisco Systems DNOS – by DriveNets Inferno – distributed OS originally from Bell Labs IOS-XR – by Cisco Systems JunOS – by Juniper Networks LCOS – by LANCOM Systems[40] Linux OpenWrt DD-WRT LEDE Gargoyle LibreCMC Zeroshell FTOS – by Force10 Networks FreeBSD m0n0wall OPNsense pfsense List of wireless router firmware projects - Other embedded Apache Mynewt ChibiOS&#x2F;RT Contiki ERIKA Enterprise eCos NetBSD Nucleus RTOS[41] NuttX Minix NCOS freeRTOS, openRTOS, safeRTOS Fuchsia OpenEmbedded (or Yocto Project) OpenHarmony pSOS (Portable Software On Silicon) QNX – Unix-like real-time operating system, aimed primarily at the embedded systems market.[42] REX OS – microkernel; usually an embedded cell phone OS RIOT ROM-DOS TinyOS ThreadX RT-Thread DSPnano RTOS Windows IoT – formerly Windows Embedded Windows CE Windows IoT Core Windows IoT Enterprise Wind River VxWorks RTOS.[17] Wombat – microkernel; usually real-time embedded Zephyr LEGO Mindstorms brickOS leJOS 介绍1234567An embedded operating system is an operating system for embedded computer systems. Embedded operating systems are computer systems designed to increase functionality and reliability for achieving a specific task.[1] Resource efficiency comes at the cost of losing some functionality or granularity that larger computer operating systems provide, including functions that may not be used by the specialized applications run. Depending on the method used for multitasking, this type of OS is frequently considered a real-time operating system or RTOS. Embedded systems are mostly used as Real-time operating systems.All embedded systems contain a processor and software. There must be a place for embedded software to store the executable code and temporary storage for run-time data manipulations. These take the form of ROM and RAM, respectively. All embedded systems must also contain some form of inputs and outputs to function. Within the exception of these few common features, the rest of the embedded hardware is usually unique and varies from application to application.[2] The hardware running an embedded operating system can be very limited in resources; therefore the embedded design of these operating systems may have a narrow scope tailored to a specific application to achieve the desired operation under these constraints. The embedded operating system that organizes and controls the hardware usually determines the rest of the embedded hardware needed.To take better advantage of the processing power of the CPU, software developers may write critical code directly in assembly. This machine efficient language can potentially result in gains in speed and determinism at the cost of portability and maintainability. Often, embedded operating systems are written entirely in more portable languages, like C, however.An important difference between most embedded operating systems and desktop operating systems is that the application, including the operating system, is usually statically linked into a single executable image. Unlike a desktop operating system, the embedded operating system does not load and execute many applications.[3] This means that the system is only able to run a few application(s). 种类，构成，应用","categories":[],"tags":[]},{"title":"2023年4月8日","slug":"2023年4月8日","date":"2023-04-08T09:32:42.000Z","updated":"2023-04-08T10:36:20.294Z","comments":true,"path":"2023/04/08/2023年4月8日/","link":"","permalink":"http://petertan303.github.io/2023/04/08/2023%E5%B9%B44%E6%9C%888%E6%97%A5/","excerpt":"","text":"用 Python 读取&amp;解析 jsonjson 范例： 123456789&#123; &quot;name&quot;: &quot;United States&quot;, &quot;population&quot;: 331002651, &quot;capital&quot;: &quot;Washington D.C.&quot;, &quot;languages&quot;: [ &quot;English&quot;, &quot;Spanish&quot; ]&#125; JSON以键值对的形式传递数据，类似XML，XML示例： 12345678910&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;country&gt; &lt;name&gt;United States&lt;/name&gt; &lt;population&gt;331002651&lt;/population&gt; &lt;capital&gt;Washington D.C.&lt;/capital&gt; &lt;languages&gt; &lt;language&gt;English&lt;/language&gt; &lt;language&gt;Spanish&lt;/language&gt; &lt;/languages&gt;&lt;/country&gt; 众所周知，Python原生支持JSON数据，json模块是标准库的一部分，无序手动解析。 可以将JSON数据从JSON格式转换到等效的Python对象，例如dictionary和list。JSON模块还可以将Python对象转换为JSON格式。 具体使用：将json字符串转化为字典传入：字符串格式的 json 数据。 123456import json# 导入json包country = &#x27;&#123;&quot;name&quot;: &quot;United States&quot;, &quot;population&quot;: 331002651&#125;&#x27;# 定义字符串，json，countrycountry_dict = json.loads(country)# 使用json.loads()方法处理country 结果country_dict是字典。 注意，json内数据类型和Python内有一一对应的关系。 JSON Python object dict array list string str number (integer) int number (real) float true True false False null None 将json文件转化为字典使用open()方法导入文件，然后使用json.loads()处理读入的字符串。 123456import jsonwith open(&#x27;united_states.json&#x27;) as f: data = json.load(f)print(type(data)) 测试结果： python 字典单向读取，打印时呈现json格式。 用 Python 调用 api12345import requestsdef request_data(url): req = requests.get(url, timeout=30) # 请求连接 req_jason = req.json() # 获取数据 return req_jason 也就是通过requests包里的requests.get(url,timeout)进行获取内容，这个方法会返回一个字符串。 Python 正则模块 reQ：如何将非标准json数据（例如nga的api）掐头去尾？ A：使用re的findall()模块 12345678# 处理形如ashdasbdh(# 中间是json# );import redt = re.findall(r&#x27;[(](.*?)[)]&#x27;, text)data_json = json.loads(dt[0])print(dt)print(data_json) vscode json 自动排版使用json tools工具内的 ctrl+alt+M快捷键","categories":[],"tags":[]},{"title":"2023年3月31日","slug":"2023年3月31日","date":"2023-03-31T14:25:42.000Z","updated":"2023-03-31T16:24:39.899Z","comments":true,"path":"2023/03/31/2023年3月31日/","link":"","permalink":"http://petertan303.github.io/2023/03/31/2023%E5%B9%B43%E6%9C%8831%E6%97%A5/","excerpt":"","text":"今天下午年级大会讲未来出路。要么读研，要么出国，要么工作。 工作属于下下策，做准备，但不打算。 保研需要本专业前23%，电子信息工程，但我是后75%，不考虑。 说到底还是成绩的问题。我没有自信能初试成绩卷到370+，因为我是后25%的逆天。 啧。还是太菜了。 另外，hexo似乎不能接受名字过长的图片，例如__original_drawn_by_mika_pikazo__9b801da3790150e87f921f3a657be815.jpg，否则不会进行上传。 如果选择考研，那么，我的选择有： 研究所 高等院校 其他院校 如，深研院等","categories":[],"tags":[]},{"title":"专业写作与口头表达作业1","slug":"专业写作与口头表达作业1","date":"2023-03-16T04:57:39.000Z","updated":"2023-03-16T10:45:04.928Z","comments":true,"path":"2023/03/16/专业写作与口头表达作业1/","link":"","permalink":"http://petertan303.github.io/2023/03/16/%E4%B8%93%E4%B8%9A%E5%86%99%E4%BD%9C%E4%B8%8E%E5%8F%A3%E5%A4%B4%E8%A1%A8%E8%BE%BE%E4%BD%9C%E4%B8%9A1/","excerpt":"","text":"截止：今晚之前 要求：? Pathology diagnostics relies on the assessment of morphology by trained experts, which remains subjective and qualitative. Here we developed a framework for large-scale histomorphometry (FLASH) performing deep learning-based semantic segmentation and subsequent large-scale extraction of interpretable, quantitative, morphometric features in non-tumour kidney histology. We use two internal and three external, multi-centre cohorts to analyse over 1000 kidney biopsies and nephrectomies. By associating morphometric features with clinical parameters, we confirm previous concepts and reveal unexpected relations. We show that the extracted features are independent predictors of long-term clinical outcomes in IgA-nephropathy. We introduce single-structure morphometric analysis by applying techniques from single-cell transcriptomics, identifying distinct glomerular populations and morphometric phenotypes along a trajectory of disease progression. Our study provides a concept for Next-generation Morphometry (NGM), enabling comprehensive quantitative pathology data mining, i.e., pathomics. from: https://www.nature.com/articles/s41467-023-36173-0 Background Image-based machine learning tools hold great promise for clinical applications in pathology research. However, the ideal end-users of these computational tools (e.g., pathologists and biological scientists) often lack the programming experience required for the setup and use of these tools which often rely on the use of command line interfaces. Methods We have developed Histo-Cloud, a tool for segmentation of whole slide images (WSIs) that has an easy-to-use graphical user interface. This tool runs a state-of-the-art convolutional neural network (CNN) for segmentation of WSIs in the cloud and allows the extraction of features from segmented regions for further analysis. Results By segmenting glomeruli, interstitial fibrosis and tubular atrophy, and vascular structures from renal and non-renal WSIs, we demonstrate the scalability, best practices for transfer learning, and effects of dataset variability. Finally, we demonstrate an application for animal model research, analyzing glomerular features in three murine models. Conclusions Histo-Cloud is open source, accessible over the internet, and adaptable for segmentation of any histological structure regardless of stain. from: https://www.nature.com/articles/s43856-022-00138-z Complex diseases are characterized by spatiotemporal cellular and molecular changes that may be difficult to comprehensively capture. However, understanding the spatiotemporal dynamics underlying pathology can shed light on disease mechanisms and progression. Here we introduce STARmap PLUS, a method that combines high-resolution spatial transcriptomics with protein detection in the same tissue section. As proof of principle, we analyze brain tissues of a mouse model of Alzheimer’s disease at 8 and 13 months of age. Our approach provides a comprehensive cellular map of disease progression. It reveals a core–shell structure where disease-associated microglia (DAM) closely contact amyloid-β plaques, whereas disease-associated astrocyte-like (DAA-like) cells and oligodendrocyte precursor cells (OPCs) are enriched in the outer shells surrounding the plaque-DAM complex. Hyperphosphorylated tau emerges mainly in excitatory neurons in the CA1 region and correlates with the local enrichment of oligodendrocyte subtypes. The STARmap PLUS method bridges single-cell gene expression profiles with tissue histopathology at subcellular resolution, providing a tool to pinpoint the molecular and cellular changes underlying pathology. from: https://www.nature.com/articles/s41593-022-01251-x 病理学检验是诸多疾病临床诊断的金标准，利用图像处理与人工智能技术对数字病 理图像进行分析，可以实现病灶的计算机辅助检测。在全扫描切片的情境下，可以进一 步获取更丰富的与肿瘤微环境、免疫微环境相关的信息，起到改进风险分层、支持治疗 决策等目的。数字病理图像分析的挑战主要来自于全扫描切片的数据体量、组织学与图 像外观的异质性、数据标注的昂贵代价，以及模型可解释性方面的需求。本文聚焦于基 于深度学习的数字病理图像分析系统，从细分领域综述、方法学研究，以及应用探索三 个方面展开工作，主要内容如下： 1、系统地总结了近期计算病理学领域的进展，并着重介绍了其在肺癌、结直肠癌、 乳腺癌切片，以及免疫组织化学染色切片和非肿瘤切片分析中的应用。在介绍相关知识 的同时，以前景识别任务为例展示了一套完整的计算病理学模型开发流程。 2、针对来自于组织学与图像外观多样性的挑战，提出了适用于大型队列的染色模式 分析工具。通过采样、聚类、色谱距离定义与求解，以及降维的步骤，对队列内全扫描 切片的颜色模式进行可视化。进一步以该方法为工具，分析了一个计算病理学模型的开 发与测试过程，得出了若干具有实践指导意义的结论。 3、针对标注数据收集代价高的挑战，提出了将深度预编码与逻辑斯蒂回归模型相结 合的方法。由于该方法的高效性，其得以集成于主动学习框架内，成为交互式标注的解 决方案。本文在三个大型数据集上验证了所提出方法的可行性，并针对编码器与主动学 习策略进行了深入的比较性研究。 4、开发了针对具体病种的计算病理学模型，并进行了有关模型的可解释性与临床意 义的探索： (a) 针对心内膜心肌活检组织病理图像，提出了临床心力衰竭检测模型，在训练VGG 模型实现病灶检测目的的同时，提出使用包括梯度-类别激活可视化技术、特征 空间的UMAP 降维，以及交叠式交叉验证等策略，提升模型输出的可解释性， 增强了信服力； (b) 针对结肠腺癌组织病理切片，提出了肿瘤微环境的自动分析方法，并验证了与肿 瘤间质、坏死、淋巴细胞相关指标的预后提示意义； (c) 针对肺癌组织病理图像，开发了基于 U-Net 的癌灶检测模型，并结合癌灶分割 结果与淋巴细胞空间分布图，提出了肿瘤与淋巴细胞交互程度的量化方法，并验 证了其预后意义。 关键词：数字病理图像，深度学习，计算病理学，计算机辅助诊断，肿瘤微环境，免 疫微环境，病灶检测 III Abstract Pathological examination is the golden standard of numerous diseases in clinics. Powered by image processing and artificial intelligence techniques, modern computer-aided diagnostic (CAD) models are able to detect lesions in histopathological images. In the context of whole-slide images, more information such as tumor microenvironment, immuno-microenvironment can be obtained. This information plays a crucial role in risk stratification and may support disease management. The challenges in digital pathological image analysis mainly include the huge data volume, the histological and apparent heterogeneity, the cost of data annotation, and the requirement of model interpretability. This thesis focuses on deep learning-based digital pathological image analytic systems, carries on the investigations from three aspects. The main contents are as follows: 1. We made a systematic summary of recent advances in computational pathology, with emphasis on its applications in lung cancer, colorectal cancer, breast cancer, immunohistochemistry-stained slides, and non-tumor disease. At the same time, we showed a full development procedure of a computational pathology model in the context of a foreground segmentation task. 2. To solve the challenge of histologic and apparent heterogeneity, we propose an analytic tool to visualize the staining pattern of large cohorts of digital slides. The method is composed of procedures including sampling, clustering, defining and solving distances between color spectrums, and dimensional reduction. Using this tool, we were able to analyze the development and deployment of a CAD model, leading to several conclusions that have practical guiding significance. 3. To deal with the expensiveness of data annotation, we propose to combine deep pre-encoding and logistic regression models. Because of the high efficiency, it can be integrated into an active learning framework, serving as a potential solution for interactive data annotation. We verified the method on three large-scale datasets, and conducted intensive comparative studies regarding the type of encoder and active learning strategy. 4. We developed a number of computational pathology models for specific diseases, and made investigations towards model interpretability and its clinical value. (a) We proposed a clinical heart failure detection model in endocardial myocardial biopsy images; along with the training of VGG models for detection task, we propose to use techniques including Grad-CAM, UMAP, and overlapped cross-validation to obtain interpretable predictions, adding convincement of the models. (b) We propose an automatic framework to quantify tumor microenvironment (TME) in Abstract IV colon adenocarcinoma slides, and verify the prognostic value of tumor stroma, necrosis, and lymphocytes distribution. (c) We also propose a U-Net-based model for cancer detection in lung specimens. Combined with the spatial distribution map of lymphocytes, we quantified the interaction between tumor cells and lymphocytes, which turned out to has prognostic value. Keywords: Digital pathological images, deep learning, computational pathology, computer-aided diagnosis, tumor microenvironment, immuno-microenvironment, lesion detection from: 腺癌是一种常发生于上皮腺体组织的癌症类型，在结直肠癌、前列腺癌、乳腺癌、 肺癌等多种恶性肿瘤中都十分常见。在病理形态上，腺癌的发生往往伴随着腺体结构分 化变差甚至不分化，即腺体组织呈现出异常变形扭曲、内部空腔结构被细胞核侵占致其 缩小甚至消失。这种不同程度的腺体分化直接与腺癌的恶性程度相关联。因此，在临床 病理诊断中，腺体组织结构的分化程度是病理学家确定腺癌等级乃至决策治疗方案的决 定性因素。 为了实现腺癌恶性程度的自动评估分级，本文从腺体结构分化程度这一病理诊断标 准出发：一方面，本文设计了领域特定的手工特征，提出了基于同源性分布统计表示的 前列腺癌自动格里森分级方法。该方法首先基于同源性分布算法计算病理图像的同源性 分量，通过描述腺体周围细胞核间的拓扑排列对腺体结构分化程度进行定量化；然后用 统计量对获得的同源性序列特征进行二次表征；最后采用加权K 近邻分类器算法建模 实现前列腺癌病理图像的自动分级。实验结果表明，相比无监督学习方法SSAE、有监 督方法DLGg 和传统病理组学方法MATF，本文方法分级表现更出色，特征也具有更好 的鲁棒性。而且，本文提出的特征表示方法具有生物学基础，可解释性强。 另一方面，启发于对腺体结构自动分割结果进行精确描述以实现诊断的思路，本文 提出基于多任务学习和先验知识的腺癌良恶自动评估方法。该方法首先利用特征学习骨 干网络进行特征提取，提取到的特征分别被送入分割分支和分类分支进行腺体结构自动 分割和腺癌图像的自动良恶分级；同时，分割分支的腺体结构预测作为先验知识被编码 为空间注意力融合到分类分支中以约束分级的推理偏好。实验结果验证了本文基于先验 知识约束的多任务网络模型的有效性，在腺癌测试集上达到最高97.04%的准确率和 0.9971 的AUC 值。而且，本文的先验知识约束思想同样具有解释性。 本文研究的基于病理图像分析的癌症恶性程度自动评估分级方法，立足自腺体结构 分化这一病理诊断标准，因而可以为病理医生提供可解释的辅助诊断支持。 关键词：腺癌，自动分级，同源性分布，先验知识，多任务学习 南京信息工程大学硕士学位论文 II Abstract Adenocarcinoma is a type of cancer that often occurs in epithelial gland tissues. It is common in malignant tumors such as colorectal cancer, prostate cancer, breast cancer, and lung cancer. In terms of pathological pattern, the occurrence of adenocarcinoma is often accompanied by poor or undifferentiated gland structure. The glands are abnormally stretched and distorted, and the cavity structures are invaded by the nuclei, causing it to shrink or even disappear. This situation is directly related to the degree of malignancy of adenocarcinoma. Therefore, the degree of differentiation of glandular structure is a decisive factor for pathologists to determine the grade of adenocarcinoma and decide the treatment plan in clinical pathological diagnosis. In this paper, to realize the automated grading of the malignant degree of adenocarcinoma, the study evolves from the degree of gland structure differentiation which is a pathological diagnostic criteria. On the one hand, this paper designs domain-specific hand-crafted features and proposes an automated gleason grading method for prostate adenocarcinoma based on the statistical representation of homology profile. This method first calculates the homology components of pathological images based on the homology profile algorithm, and quantifies the degree of gland structure differentiation by describing the topological arrangement of nuclei around the gland. Then it employs statistical methods for secondary characterization on the obtained homology sequence characteristics. The method finally models the weighted Knearest neighbor classifier algorithm for automated gleason grading of pathological images on adenocarcinoma. Experimental results show that this method performs better in grading and features robustness, compared with unsupervised learning method SSAE, supervised method DLGg and traditional pathomics-based method MATF. In addition, the proposed homology feature representation method has a strong biological basis and is highly interpretable. On the other hand, inspired by the idea of accurately describing the automatic segmentation of glandular structures for diagnosis, this paper proposes an automated assessment method for colorectal adenocarcinoma based on multi-task learning and prior knowledge. Firstly, this method employs the backbone network for feature extraction, and the extracted features are respectively sent to the segmentation branch and classification branch for automated gland structure segmentation and grading of adenocarcinoma images. Meanwhile, the automated Abstract III gland structure prediction from the segmentation branch acts as the prior knowledge, and it is encoded as spatial attention and merged into the classification branch to constrain the reasoning. The experimental results verify the effectiveness of the prior knowledge-aware multi-task network, achieving the highest accuracy of 97.04% and AUC value of 0.9971 on the test set. Moreover, the idea of prior knowledge constraint in this paper is also interpretable. The automated assessment grading methods based on pathological image analysis are proposed for cancer malignancy. Importantly, the glandular structure differentiation acting as the pathological diagnosis criteria is fundamental to them. The methods thus can provide pathologists with interpretable auxiliary diagnosis support. Key words: Adenocarcinoma, Automated grading, Homology profile, Prior knowledge, Multitask learning from: 病理图像分割是进行病理图像定量分析的重要基础，在疾病的研究、临床诊断、治 疗和预后中具有重要的价值。传统的分割方法一般为手动或半自动的方法，在分割效率 或准确性上远远不能满足临床需求。病理图像的分析相比于自然图像更加困难，目前的 深度学习分割模型在病理图像的分割任务中仍然存在分割的准确率和鲁棒性都比较低 的问题。造成这些问题的主要原因是一般的深度学习分割模型主要依赖于预定义的损失 函数训练机制进行训练，因此不能较好的衡量出模型输出和真实标记之间的误差并指导 模型的训练。 本文基于生成对抗网络(GAN)和条件生成对抗网络(cGAN)的基本原理在多种病理 图像分析任务中构建了组织和细胞层次的分割模型，基于分割的结果发现了许多疾病关 联的视觉或亚视觉特征，并将这些特征用于临床辅助诊断和预后。在病理图像分析任务 中，本文基于cGAN 构建了以下的分割模型和框架：(1)构建了H&amp;E 染色病理图像中的 细胞核语义分割和实例分割模型SIcGAN，该模型可以对所有的细胞核进行精确的语义 分割；(2)构建了乳腺H&amp;E 染色病理图像中上皮和间质区域的自动分割模型EPScGAN， 和当前主流的图像分割模型对比，EPScGAN 可以达到最优的分割性能；(3)针对急性髓 性白血病(AML)染色病理涂片中髓性细胞(Myeloblast)的检测和分割，构建了AMLcGAN 分割和检测的模型及框架。另外，基于成髓性细胞的分割结果提取了成髓性细胞的图像 特征来对骨髓转移治疗的有效性进行了预测。(4)为了能够精确诊断慢性髓性白血病 (CML)，构建了CML 染色病理切片中巨核细胞(Megakaryocyte)的检测和分割模型 MKcGAN，然后基于分割结果提取了巨核细胞的统计学特征对CML 进行了有效地诊断。 (5)在口腔癌的H&amp;E 染色病理图像中，构建了多细胞核(MN)的分割和检测模型 MNSDcGAN，并且在多家单位提供的总共758 个全扫描图像(WSI)病例中进行了测试， 最终发现提取的MN 特征与口腔癌病人的5 年生存率密切相关。 关键字：病理图像分析，条件生成对抗网络(GAN) 南京信息工程大学硕士学位论文 II Abstract The segmentation of histologic images is an important prerequisite for medical image analysis, and has important value in disease research, clinical diagnosis, treatment and prognosis. The traditional segmentation method is generally a manual or semi-automatic method, which is far from meeting the clinical needs in terms of segmentation efficiency or accuracy. Compared with natural images, pathological image recognition is more difficult. The current deep learning segmentation model still has the problem of low segmentation accuracy and robustness in the segmentation task of pathological images. The main reason for these problems is that the general deep learning segmentation model mainly relies on the pre-defined loss function training mechanism for training, so it cannot measure the error between the model output and the true label and guide the model training. In this paper, based on the basic principles of generative adversarial networks (GAN) and conditional generative adversarial networks (cGAN), segmentation models at the tissue and cell levels are constructed in a variety of pathological image analysis tasks. Based on the results of segmentation, many disease-related visual or sub-visual Visual features, and use these features for clinical auxiliary diagnosis and prognosis. In the pathological image analysis task, this paper constructed the following segmentation model and framework based on cGAN: (1) Constructed the semantic segmentation of nuclei in H &amp; E stained pathological images and the instance segmentation model SIcGAN, which can carry out precise semantics on all nuclei Segmentation; (2) Constructed an automatic segmentation model EPScGAN of epithelial and interstitial regions in H &amp; E stained pathological images of breast. Compared with the current mainstream image segmentation model, EPScGAN can achieve optimal segmentation performance; Detection and segmentation of myeloblast (Myeloblast) in the pathological smear of leukemia (AML), constructed the model and framework of AMLcGAN segmentation and detection, and then extracted the image features of Myeloblast based on the segmentation result of Myeloblast to be effective for bone marrow metastasis Sex was predicted. (4) For the diagnosis of chronic myeloid leukemia (CML), a megakaryocyte (Megakaryocyte) detection and segmentation model in CML stained pathological sections was constructed, and then the statistical characteristics of Megakaryocytes were extracted based on the segmentation results. diagnosis. 摘要 III (5) In the H &amp; E stained pathological image of oral cancer, a multi-cell nuclei (MN) segmentation and detection model MNSDcGAN was constructed, and tested in a total of 758 full-scan image (WSI) cases provided by multiple units, and finally found The extracted MN features are closely related to the 5-year survival rate of oral cancer patients. Key words: Histology image analysis, conditional Generative Adversarial Network 病理图像的概念 综述论文结构 病理图像分析主要方法（框图） 数据库、源代码 病理图像的概念利用图像处理与人工智能技术对数字病理图像进行分析，可以实现病灶的计算机辅助检测。在全扫描切片的情境下，可以进一步获取更丰富的与肿瘤微环境、免疫微环境相关的信息，起到改进风险分层、支持治疗决策等目的。数字病理图像分析的挑战主要来自于全扫描切片的数据体量、组织学与图像外观的异质性、数据标注的昂贵代价，以及模型可解释性方面的需求。 综述论文结构 介绍背景： 领域现在的发展 仍然存在的问题 介绍研究本身 研究的手段 所研究的问题 研究的具体方法 研究的意义 关键词 病理图像分析主要方法（框图）暂定","categories":[],"tags":[]},{"title":"专业认知与探索期末作业","slug":"专业认知与探索期末作业","date":"2023-03-16T02:58:26.000Z","updated":"2023-03-18T02:26:21.211Z","comments":true,"path":"2023/03/16/专业认知与探索期末作业/","link":"","permalink":"http://petertan303.github.io/2023/03/16/%E4%B8%93%E4%B8%9A%E8%AE%A4%E7%9F%A5%E4%B8%8E%E6%8E%A2%E7%B4%A2%E6%9C%9F%E6%9C%AB%E4%BD%9C%E4%B8%9A/","excerpt":"","text":"截止时间：周五，也就是明天晚上 要求： 期末题目：用TX-1C学习板实现下列题目中的一个，每人独立完成。 必须完成基本要求，其它功能可以自行添加。 用学习板和超声模块实现超声测距，并用点阵或液晶显示。基本要求：使用超声测距模块进行距离测试，用点阵显示超声波测试的距离，距离越近，点阵中亮的点越少；距离越远，点阵中亮的点越多。（超声测距模块需要大家自己购买，参考型号是HC-SR04） 用学习板和超声模块实现超声测距，并用数码管显示距离。基本要求：使用超声测距模块进行距离测试，并用数码管显示测距结果。（超声测距模块需要大家自己购买，参考型号是HC-SR04） 利用键盘和1602液晶显示器实现简易计算器基本要求：利用矩阵键盘和独立键盘实现一个计算器，计算器必须具备加减乘除功能，并利用1602液晶显示输入的数据和计算结果。计算器的其它功能根据个人能力添加。 利用键盘和数码管实现简易计算器基本要求：利用矩阵键盘和独立键盘实现一个计算器，计算器必须具备加减乘除功能，并利用数码管显示输入的数据和计算结果。计算器的其它功能根据个人能力添加。 利用键盘、发光二极管和数码管实现一个交通信号灯基本要求：指定发光二极管代表红黄绿灯，绿灯亮20s后，黄灯闪烁3s，然后红灯再亮20s，交替变化。当红灯只剩5s时长时，数码管按秒显示倒计时；当绿灯只剩5s时长时，数码管按秒显示倒计时；黄灯工作的3s期间，指定某个发光二极管以500ms为间隔闪烁。根据个人能力实现单向或十字路口交通灯。 基于课程所学内容，自己拟定实验项目和内容，完成实验，并提交报告。 注意：期末项目电子版实验报告提交给助教，报告以“学号+姓名+期末题目”形式命名，时间可以放宽到下学期开学第三周之前。是否安排现场验收，视疫情情况而定。 没有超声模块，排除1、2 选择4：数码管、键盘、计算器 1602液晶显示屏不熟悉，排除 交通灯：考虑 计算器： 计算：加减乘除 需要指定按键：keyscan()，使用所有键盘 十个数字：0~9 加减乘除，四个以上 清零 其他功能 显示屏：display()，显示加减乘除的符号、数字 应该没了？ 交通灯： 指定发光二极管代表红黄绿灯 绿灯亮20s后，黄灯闪烁3s，然后红灯再亮20s，交替变化。 当红灯只剩5s时长时，数码管按秒显示倒计时；当绿灯只剩5s时长时，数码管按秒显示倒计时；黄灯工作的3s期间，指定某个发光二极管以500ms为间隔闪烁。根据个人能力实现单向或十字路口交通灯。 单向： 四个灯，绿灯红灯黄灯和500ms闪烁灯 计时： 绿灯20s，黄灯3s和闪烁灯500ms爆闪，红灯20s 数码管5s倒计时：红灯、绿灯；3s倒计时：黄灯 没了？ 十字路口： 两个单向？ 计算器： 数字表 有小数点 无小数点 运算 display() 实时显示数字，不显示符号 keyscan() - 计算器 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149#include &lt;reg52.h&gt;//定义行引脚sbit hang[]=&#123;P3^7,P3^6,P3^5,P3^4&#125;; //定义列引脚sbit lie[]=&#123;P3^3,P3^2,P3^1,P3^0&#125;;char key[4][4]=&#123; &#123;&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;k&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;=&#x27;&#125;, &#123;&#x27;a&#x27;, &#x27;m&#x27;, &#x27;x&#x27;, &#x27;p&#x27;&#125;&#125;;// 加减乘除int num[7]=&#123;0&#125;;int cal_num[2]=&#123;0&#125;;char fuhao=0;unsigned char code num1[]= //没有小数点的0-9对应编码&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;unsigned char code num2[]= &#123;0xbf,0x86,0xdb,0xcf,0xe6,0xed,0xfd,0x87,0xff,0xef&#125;;unsigned char code place[]=&#123;0xfe,0xfd,0xfb,0xf7,0xf5,0xf3,0xf1&#125;;void delay(int z)&#123; int i,j; for(i=z;i&gt;0;i--); for(j=110;j&gt;0;j--);&#125;void display()&#123; int i=0; int temp = cal_num[0]; for(i=0;i&lt;7&amp;&amp;temp&gt;0;i++)&#123; num[i]=temp%10; temp/=10; &#125; for(i=0;i&lt;7;i++)&#123; wela=1; P0=place[i]; wela=0; P0=0x00; dula=1; //P0=(i==1?num2[num[i]]:num1[num[i]]); P0 = cal_num[1]; delay(10); dula=0; P0=0xff; &#125; return;&#125;char keyscan()&#123; char input; int i=0,j=0; for(j=0;j&lt;4;j++)&#123; P3=0xff; hang[j]=0; for(i=0;i&lt;4;i++)&#123; if(lie[i]==0) &#123; delay(10); if(lie[i]==0) &#123; while(lie[i]==0); input=key[i][j]; &#125; &#125; &#125; &#125; return input;&#125;int calculate(char input)&#123; int temp=0; switch(input)&#123; case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;: case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;: case &#x27;0&#x27;: cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;) break; case &#x27;a&#x27;: case &#x27;m&#x27;: case &#x27;x&#x27;: case &#x27;p&#x27;: case &#x27;=&#x27;: switch(fuhao)&#123; case &#x27;a&#x27;: cal_num[0]+=cal_num[1]; break; case &#x27;m&#x27;: cal_num[0]-=cal_num[1]; break; case &#x27;x&#x27;: cal_num[0]*=cal_num[1]; break; case &#x27;p&#x27;: cal_num[0]/=cal_num[1]; break; case &#x27;=&#x27;: case default: break; &#125; cal_num[1]=0; fuhao = input; break; case default: break; &#125;&#125;void main()&#123; //init char input=0; //begin while(1)&#123; display(); input = keyscan(); calculate(input); &#125; return;&#125; 修改后 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527528529530531532533534535536537538539540541542543544545546547548549550551552553554555556557558559560561562563564565566567568569#include &lt;reg52.h&gt;sbit dula=P2^6; //dula与wela为两个使能端sbit wela=P2^7;////定义行引脚sbit lie1=P3^7;sbit lie2=P3^6;sbit lie3=P3^5;sbit lie4=P3^4;// ////定义列引脚sbit hang1=P3^3;sbit hang2=P3^2;sbit hang3=P3^1;sbit hang4=P3^0;char key[4][4]=&#123; &#123;&#x27;7&#x27;,&#x27;8&#x27;,&#x27;9&#x27;,&#x27;0&#x27;&#125;, &#123;&#x27;4&#x27;,&#x27;5&#x27;,&#x27;6&#x27;,&#x27;k&#x27;&#125;, &#123;&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;,&#x27;=&#x27;&#125;, &#123;&#x27;a&#x27;, &#x27;m&#x27;, &#x27;x&#x27;, &#x27;p&#x27;&#125;&#125;;// 加减乘除long int cal_num[3]=&#123;0,0,0&#125;;char fuhao=0;char input=0;unsigned char code num1[]= //没有小数点的0-9对应编码&#123;0x3f,0x06,0x5b,0x4f,0x66,0x6d,0x7d,0x07,0x7f,0x6f&#125;;unsigned char code num2[]= &#123;0xbf,0x86,0xdb,0xcf,0xe6,0xed,0xfd,0x87,0xff,0xef&#125;;unsigned char code place[]=&#123; //0111_1111 7f //1011_1111 bf //1101_1111 df //1110_1111 ef //1111_0111 f7 //1111_1011 fb //1111_1101 fd //1111_1110 fe0xfe,0xfd,0xfb,0xf7,0xef,0xdf,0xbf,0x7f&#125;;void delay(int z)&#123; int i,j; for(i=z;i&gt;0;i--); for(j=110;j&gt;0;j--);&#125;void display()&#123; int i=0; int temp = cal_num[2];// for(i=0;i&lt;7&amp;&amp;temp&gt;0;i++)&#123;// num[i]=temp%10;// temp/=10;// &#125; for(i=5;i&gt;0/*&amp;&amp;temp&gt;0*/;i--)&#123; wela=1; P0=place[i]; wela=0; P0=0x00; dula=1; P0 = num1[temp%10]; temp/=10; delay(10); dula=0; P0=0xff; &#125; delay(100); return;&#125;//char keyscan()//&#123;// char input;// int i=0,j=0;// for(j=0;j&lt;4;j++)&#123;// P3=0xff;// hang[j]=0;// for(i=0;i&lt;4;i++)&#123;// if(lie[i]==0)// &#123;// delay(10);// if(lie[i]==0)// &#123;// while(lie[i]==0);// input=key[i][j];// &#125;// &#125;// &#125;// &#125;// return input;//&#125;//char keyscan()&#123;//&#123;// char input=0;// P3|=0xff;// hang1=0;// if(lie1==0)// &#123;// delay(10);// if(lie1==0)// &#123;// while(lie1==0);// input=key[0][0];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // if(lie2==0)// &#123;// delay(10);// if(lie2==0)// &#123;// while(lie2==0);// input=key[0][1];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // // if(lie3==0)// &#123;// delay(10);// if(lie3==0)// &#123;// while(lie3==0);// input=key[0][2];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // if(lie4==0)// &#123;// delay(10);// if(lie4==0)// &#123;// while(lie4==0);// input=key[0][3];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // // P3|=0xff;// hang2=0;// if(lie1==0)// &#123;// delay(10);// if(lie1==0)// &#123;// while(lie1==0);// input=key[1][0];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // if(lie2==0)// &#123;// delay(10);// if(lie2==0)// &#123;// while(lie2==0);// input=key[1][1];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // // if(lie3==0)// &#123;// delay(10);// if(lie3==0)// &#123;// while(lie3==0);// input=key[1][2];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // if(lie4==0)// &#123;// delay(10);// if(lie4==0)// &#123;// while(lie4==0);// input=key[1][3];// &#125;// &#125;// // P3|=0xff;// hang3=0;// // if(lie1==0)// &#123;// delay(10);// if(lie1==0)// &#123;// while(lie1==0);// input=key[2][0];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // if(lie2==0)// &#123;// delay(10);// if(lie2==0)// &#123;// while(lie2==0);// input=key[2][1];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // // if(lie3==0)// &#123;// delay(10);// if(lie3==0)// &#123;// while(lie3==0);// input=key[2][2];// cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;);// &#125;// &#125;// // if(lie4==0)// &#123;// delay(10);// if(lie4==0)// &#123;// while(lie4==0);// input=key[2][3];// cal_num[1]=0;// fuhao = input;// &#125;// &#125;// // // P3|=0xff;// hang4=0;// // if(lie1==0)// &#123;// delay(10);// if(lie1==0)// &#123;// while(lie1==0);// input=key[3][0];// cal_num[0]+=cal_num[1];// cal_num[1]=0;// fuhao = input;// &#125;// &#125;// // if(lie2==0)// &#123;// delay(10);// if(lie2==0)// &#123;// while(lie2==0);// input=key[3][1];// cal_num[0]-=cal_num[1];// cal_num[1]=0;// fuhao = input;// &#125;// &#125;// // // if(lie3==0)// &#123;// delay(10);// if(lie3==0)// &#123;// while(lie3==0);// input=key[3][2];// cal_num[0]*=cal_num[1];// cal_num[1]=0;// fuhao = input;// &#125;// &#125;// // if(lie4==0)// &#123;// delay(10);// if(lie4==0)// &#123;// while(lie4==0);// input=key[3][3];// cal_num[0]/=cal_num[1];// cal_num[1]=0;// fuhao = input;// &#125;// &#125;// return input;//&#125;//&#125;char keyscan()&#123;&#123; char input=0; P3|=0xff; hang1=0; if(lie1==0) &#123; delay(10); if(lie1==0) &#123; while(lie1==0); input=key[0][0]; &#125; &#125; if(lie2==0) &#123; delay(10); if(lie2==0) &#123; while(lie2==0); input=key[0][1]; &#125; &#125; if(lie3==0) &#123; delay(10); if(lie3==0) &#123; while(lie3==0); input=key[0][2]; &#125; &#125; if(lie4==0) &#123; delay(10); if(lie4==0) &#123; while(lie4==0); input=key[0][3]; &#125; &#125; P3|=0xff; hang2=0; if(lie1==0) &#123; delay(10); if(lie1==0) &#123; while(lie1==0); input=key[1][0]; &#125; &#125; if(lie2==0) &#123; delay(10); if(lie2==0) &#123; while(lie2==0); input=key[1][1]; &#125; &#125; if(lie3==0) &#123; delay(10); if(lie3==0) &#123; while(lie3==0); input=key[1][2]; &#125; &#125; if(lie4==0) &#123; delay(10); if(lie4==0) &#123; while(lie4==0); input=key[1][3]; &#125; &#125; P3|=0xff; hang3=0; if(lie1==0) &#123; delay(10); if(lie1==0) &#123; while(lie1==0); input=key[2][0]; &#125; &#125; if(lie2==0) &#123; delay(10); if(lie2==0) &#123; while(lie2==0); input=key[2][1]; &#125; &#125; if(lie3==0) &#123; delay(10); if(lie3==0) &#123; while(lie3==0); input=key[2][2]; &#125; &#125; if(lie4==0) &#123; delay(10); if(lie4==0) &#123; while(lie4==0); input=key[2][3]; &#125; &#125; P3|=0xff; hang4=0; if(lie1==0) &#123; delay(10); if(lie1==0) &#123; while(lie1==0); input=key[3][0]; &#125; &#125; if(lie2==0) &#123; delay(10); if(lie2==0) &#123; while(lie2==0); input=key[3][1]; &#125; &#125; if(lie3==0) &#123; delay(10); if(lie3==0) &#123; while(lie3==0); input=key[3][2]; &#125; &#125; if(lie4==0) &#123; delay(10); if(lie4==0) &#123; while(lie4==0); input=key[3][3]; &#125; &#125; return input;&#125;&#125;void calculate(char input)&#123; switch(input)&#123; case &#x27;1&#x27;: case &#x27;2&#x27;: case &#x27;3&#x27;: case &#x27;4&#x27;: case &#x27;5&#x27;: case &#x27;6&#x27;: case &#x27;7&#x27;: case &#x27;8&#x27;: case &#x27;9&#x27;: case &#x27;0&#x27;: cal_num[1] = cal_num[1]*10 + ((int)input - &#x27;0&#x27;); cal_num[2] = cal_num[1]; break; case &#x27;a&#x27;: case &#x27;m&#x27;: case &#x27;x&#x27;: case &#x27;p&#x27;: case &#x27;=&#x27;: switch(fuhao)&#123; case &#x27;a&#x27;: cal_num[1]+=cal_num[0]; break; case &#x27;m&#x27;: cal_num[1]=cal_num[0]-cal_num[1]; break; case &#x27;x&#x27;: cal_num[1]*=cal_num[0]; break; case &#x27;p&#x27;: cal_num[1]=cal_num[0]/cal_num[1]; break; case &#x27;=&#x27;: default: break; &#125; cal_num[2]=cal_num[1]; cal_num[0]=cal_num[1]; cal_num[1]=0; fuhao = input; break; case &#x27;k&#x27;: cal_num[0]=cal_num[1]=cal_num[2]=cal_num[3]=0; delay(10); break; default: break; &#125; input = 0; return;&#125;void main()&#123; //init input = 0; //cal_num[1]=123456; //display(); //begin while(1)&#123;// cal_num[1]=12345; display(); delay(10); input = keyscan(); if(input!=0) calculate(input); &#125; return;&#125;","categories":[],"tags":[]},{"title":"2023年3月6日","slug":"2023年3月6日","date":"2023-03-06T04:43:05.000Z","updated":"2023-03-06T05:50:44.661Z","comments":true,"path":"2023/03/06/2023年3月6日/","link":"","permalink":"http://petertan303.github.io/2023/03/06/2023%E5%B9%B43%E6%9C%886%E6%97%A5/","excerpt":"","text":"昨天的 “ jj ” 是龚写的。 环境变量可以通过alias设置别名，但不能永久保存，下一次启动shell时会重置。 PATH即是一个环境变量。Ubuntu中，有系统环境变量和用户环境变量，区别在于对所有用户生效还是仅对当前用户生效。 环境变量的储存文件： 12345~/.profile# 无论是通过控制台还是图形界面启动程序时，都会自动执行该文件。~/.bashrc, ~/.bash_profile, ~/.bash_login# 当通过shell启动程序时，它们也会被加载；但当通过图形界面环境启动程序时，这些文件中的环境变量设置便不可用了。 环境变量的储存文件夹： 12345/etc/profile/etc/profile.d/etc/bash.bashrc /etc/profile.d文件夹来源于/etc/profile，目录下的*.sh，即以sh为后缀的文件都会被加载。 在图形界面环境下启动程序时，不会加载/ect/bash.bashrc里边的环境变量设置。 设置永久环境变量实例 编辑/etc/profile export 别名=&#39;指令&#39; 加载环境变量： 1source /etc/profile cat 命令cat（英文全拼：concatenate）命令用于连接文件并打印到标准输出设备上。 1cat [-AbeEnstTuv] [--help] [--version] fileName -n 或 –number：由 1 开始对所有输出的行数编号。 -b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。 -s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。 -v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。 -E 或 –show-ends : 在每行结束处显示 $。 -T 或 –show-tabs: 将 TAB 字符显示为 ^I。 -A, –show-all：等价于 -vET。 -e：等价于”-vE”选项； -t：等价于”-vT”选项； 用法： 123456789cat A B &gt; C# 将文件B中的内容加上A，写入C中cat A B C &gt;&gt; D# 将B与C之间加上A，写入D中cat /dev/null &gt;&gt; A# 清空A 将语句写入环境变量： echo &#39;PATH=&quot;$PATH:./node_modules/.bin&quot;&#39; &gt;&gt; ~/.profile 如何将文件夹变为 git 版本库 进入文件夹 git init 将文件添加到本地仓库：git add 可以同时添加多个文件，用空格隔开 提交：git commit -m &quot;对于本次提交的说明&quot;","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://petertan303.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"jj","slug":"jj","date":"2023-03-05T10:52:07.000Z","updated":"2023-03-05T10:58:11.928Z","comments":true,"path":"2023/03/05/jj/","link":"","permalink":"http://petertan303.github.io/2023/03/05/jj/","excerpt":"","text":"AI绘画基于本地的python,python具体是啥还需自学。linux指令略知一二，ls ls-，rm，cd，ssh，hexo。。。 非常多，还需自学。 香橙派类似于一微型电脑，有一具体应用程序，可以进行相应指令输入， 阿里云盘。。 从头开始学习python以及linux，学习到何种程度具体情况具体分析。","categories":[],"tags":[]},{"title":"2023年3月5日","slug":"2023年3月5日","date":"2023-03-05T05:27:13.000Z","updated":"2023-03-05T05:58:11.271Z","comments":true,"path":"2023/03/05/2023年3月5日/","link":"","permalink":"http://petertan303.github.io/2023/03/05/2023%E5%B9%B43%E6%9C%885%E6%97%A5/","excerpt":"","text":"买的小音箱给送到南京去了。 物件 价格 购买平台 备注 orange pi zero 2 本体 + 扩展板 158.90 淘宝 12元运费，总计170.90 闪迪64G内存卡 套餐 41.90 淘宝 - 0.5m hdmi线 0.99 淘宝 特惠买的，没啥用 usb 转 ttl 刷机板 4.00 淘宝 - 5v xh2.54 风扇 2.00 淘宝 - 5v3a 电源 7.00 淘宝 卖家未发货，退款 蓝牙音箱 11.9 拼多多 送到南京去了 总计 238.69 - - orange pi zero 2 进展我的香橙派连接的是寝室网络，一直在纠结要如何在寝室外使用。 刚刚意识到可以直接通过 ttl 串口登录香橙派，不一定需要 ssh 或远程桌面或显示屏。这样只需要带上电脑和 ttl 转接头和杜邦线就行了。 下一步计划是 GUI 制作。- Microwindows- MiniGui- QT- Gtk+- OpenGUI- FLTK- LingLongGUI- LearningGUI今天做了什么买了大物实验II的实验书、买了数字系统实验II的书和报告册。 然后上午摸鱼摸了一上午。 作业 周一 电磁场与波 信号与系统 需要作业本 IT英语 暂时没有作业，潜在项目 神经网络导论 周二 美术鉴赏 微处理器与嵌入式系统 可能有 人工智能基础 大物实验II 预习实验？ 周三 python语言程序设计及其应用 似乎有作业 周四 数字系统实验 asd 学术规范与论文写作 周五 唐球","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://petertan303.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"2023年3月4日","slug":"2023年3月4日","date":"2023-03-04T15:32:31.000Z","updated":"2023-03-05T05:26:10.822Z","comments":true,"path":"2023/03/04/2023年3月4日/","link":"","permalink":"http://petertan303.github.io/2023/03/04/2023%E5%B9%B43%E6%9C%884%E6%97%A5/","excerpt":"","text":"买了香橙派 zero 2，租了阿里云服务器。 阿里云服务器已经实现的： ftp 服务器安装 wordpress 服务器安装 远程桌面 vnc 安装 MySql 数据库 香橙派 zero 2最近一直在摆弄。安装过程中，碰上的问题： 烧录错误镜像 Paragon ExtFS for Windows无法读取 sd 卡内容 成功配置了 wi-fi，ssh，音乐播放，安装桌面 烧录镜像完成后，遇到的问题有： 端口设置开放： 先用iptables -I INPUT -p tcp --dport 端口号 -j ACCEPT 设置需要开放端口号、权限、协议 iptables-save保存 sudo netfilter-persistent save永久保存 下一次使用需要sudo netfilter-persistent reload ftp 搭建失败 未解决 aplay 调节音量：差点把自己弄聋（开玩笑） man aplay查看帮助 aplay -D plughw:0,0 xxx.wav指定播放设备 alsamixer设置音量 broot 安装失败 直接下载安装包，未解决 git 无法提交 重新设置 putty push 的时候卡在最后：添加参数sendpack.sideband git config --global sendpack.sideband false git config --local sendpack.sideband false 网络更换手机热点 conda 很慢很卡 安装mamba 安装 vnc 失败 未解决 解压 rar 需要 unrar e 包名（直接解压）或 unrar x 包名（创建新目录） 买了风扇、蓝牙音箱等等配件。 清单： 物件 价格 购买平台 备注 orange pi zero 2 本体 + 扩展板 158.90 淘宝 12元运费 闪迪64G内存卡 套餐 41.90 淘宝 0.5m hdmi线 0.99 淘宝 特惠买的，没啥用 usb 转 ttl 刷机板 4.00 淘宝 5v xh2.54 风扇 2.00 淘宝 5v3a 电源 7.00 淘宝 卖家未发货，退款 蓝牙音箱 11.9 拼多多 本来打算买有线喇叭，脑子一热就买了 vist借龚的电脑跑出了模型。遇到的问题有： 安装包需要 anaconda pip 换源 临时：pip install -i https://pypi.tuna.tsinghua.edu.cn/simple some-package 永久：pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple numpy 和 python 版本不匹配 卸载重装 安装 cuda 官网下载安装 占用储存巨大 requirements.txt 依赖没写完整 手动安装依赖 pip、conda 无法卸载 python 用 conda 直接安装 另一个版本的 python 或者用 anaconda 创建一个全新环境，创建时配置默认 python 但是储存占用……好吧、必要的牺牲 我自己电脑配置环境，遇到的问题： 最大问题：显存过小，至少需要 4.3G 而我只有 4G conda 无法更换 python 版本 同龚 但是龚的电脑可以随便折腾，不用担心储存不够。真的爽！ stable-diffusion 绘图时间太久了，想不起来，下次再写","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://petertan303.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"2023年2月5日","slug":"2023年2月5日","date":"2023-02-05T11:17:48.000Z","updated":"2023-02-05T11:26:19.500Z","comments":true,"path":"2023/02/05/2023年2月5日/","link":"","permalink":"http://petertan303.github.io/2023/02/05/2023%E5%B9%B42%E6%9C%885%E6%97%A5/","excerpt":"","text":"测试网易云音乐的插件 原版 测试增大高度 测试自动播放 测试边框","categories":[],"tags":[{"name":"Test","slug":"Test","permalink":"http://petertan303.github.io/tags/Test/"}]},{"title":"2023年1月24日","slug":"2023年1月24日","date":"2023-01-24T03:44:18.000Z","updated":"2023-03-05T05:26:53.577Z","comments":true,"path":"2023/01/24/2023年1月24日/","link":"","permalink":"http://petertan303.github.io/2023/01/24/2023%E5%B9%B41%E6%9C%8824%E6%97%A5/","excerpt":"","text":"思考ing 这学期： 数电 工数 大物 大物实验 数据结构 专业认知 概率论 下学期： 电磁场与波 信号与系统 IT英语（专用外语） 神经网络导论 微处理器与嵌入式系统 人工智能基础 美术鉴赏 大物实验II Python 语言程序设计及应用 改革开放专题史讲座 数字系统实验 学术规范与论文写作 电工电气技术实训 关于培养计划关于保研智育成绩某门课程学分积＝该门课程成绩×该门课程学分 ×加权系数 学分加权平均成绩＝相关课程学分积总和÷相关课程学分总和 注：成绩计算均以正考成绩为准，重修和补考成绩不适用于推免。经学院、教务处受理备案的缓考成绩按正考成绩计算。也就是说，挂的微积分按照50+计分 纳入推免学科： 公共必修课：思政 思想道德与法治：66，3 军事理论课：88，2 四学期的体育课 1：83，1 2：95，1 3： 4： 外语必修 1：85，4 2：85，2 外语限选 4： 数理基础课 微积分I：78，6 微积分II：60，5 线性代数与空间解析几何I：75，4 概率论与数理统计： 大学物理I：93，4 大学物理II： 学院要求课- 高级语言程序设计：94，3.5- 电路分析与电子电路：71，4 专业核心课 集中实践课程（必修）： 军事训练 电装实习 电子电路实验 数字逻辑系统实验 电工电气技术实训 基础工程训练 集中实践课程（限选）（前三门） 不纳入推免学科： 通识教育课 专业限选课 多元化教育课 科创成果","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://petertan303.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"2023年1月21日","slug":"2023年1月21日","date":"2023-01-21T11:43:16.000Z","updated":"2023-01-21T12:32:29.799Z","comments":true,"path":"2023/01/21/2023年1月21日/","link":"","permalink":"http://petertan303.github.io/2023/01/21/2023%E5%B9%B41%E6%9C%8821%E6%97%A5/","excerpt":"","text":"http-serverhttp-server可以通过在本地文件夹内运行来实现预览网站的功能。或者说，让任意一个目录成为服务器的目录。默认打开index.html，如果没有，会生成一个默认网页，里面有文件夹内所有内容。 一般默认的网址为192.168.1.2:8081和127.0.0.1:8081，前者可以通过在同一路由下的其他设备访问，后者只能在本设备内查看。 “程序员游戏” 网页游戏： https://screeps.com/ https://codecombat.cn/play https://www.codingame.com/start https://www.binancemag.com/?id=23707 steam 游戏： SHENZHEN I&#x2F;O SpaceChem TIS - 100 Human Source Machine A &#x3D; B","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://petertan303.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"试图学习CSS","slug":"试图学习CSS","date":"2023-01-20T03:54:55.000Z","updated":"2023-01-20T05:06:57.050Z","comments":true,"path":"2023/01/20/试图学习CSS/","link":"","permalink":"http://petertan303.github.io/2023/01/20/%E8%AF%95%E5%9B%BE%E5%AD%A6%E4%B9%A0CSS/","excerpt":"","text":"基本语法格式CSS &#x3D; 选择器 + 声明块 例： 1234p &#123; color: red; text-align: center;&#125; p 为选择器，指向&lt;p&gt;标签。属性 - 冒号 - 属性值 - 分号。 注释同 C ，/*注释*/。 CSS的使用 外部CSS 例如，html内的一句&lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt;，指向mystyle.css： 12345678body &#123; background-color: lightblue;&#125;h1 &#123; color: navy; margin-left: 20px;&#125; 内部css html文件中，head部分的&lt;style&gt;元素中进行定义。 123456789101112131415161718192021&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;body &#123; background-color: linen;&#125;h1 &#123; color: maroon; margin-left: 40px;&#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;This is a heading&lt;/h1&gt;&lt;p&gt;This is a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 行内css（内联样式） 将style属性赋予某个元素。 123456789&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1 style=&quot;color:blue;text-align:center;&quot;&gt;This is a heading&lt;/h1&gt;&lt;p style=&quot;color:red;&quot;&gt;This is a paragraph.&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 层叠顺序当为某个 HTML 元素指定了多个样式时，会使用哪种样式呢？ 页面中的所有样式将按照以下规则“层叠”为新的“虚拟”样式表，其中第一优先级最高： 1.行内样式（在 HTML 元素中） 2.外部和内部样式表（在 head 部分） 3.浏览器默认样式 因此，行内样式具有最高优先级，并且将覆盖外部和内部样式以及浏览器默认样式。 css内容颜色 颜色名 赋颜色的一种方式 背景色 12&lt;h1 style=&quot;background-color:DodgerBlue;&quot;&gt;China&lt;/h1&gt;&lt;p style=&quot;background-color:Tomato;&quot;&gt;China is a great country!&lt;/p&gt; 文本颜色 123&lt;h1 style=&quot;color:Tomato;&quot;&gt;China&lt;/h1&gt;&lt;p style=&quot;color:DodgerBlue;&quot;&gt;China is a great country!&lt;/p&gt;&lt;p style=&quot;color:MediumSeaGreen;&quot;&gt;China, officially the People&#x27;s Republic of China...&lt;/p&gt; 边框颜色 123&lt;h1 style=&quot;border:2px solid Tomato;&quot;&gt;Hello World&lt;/h1&gt;&lt;h1 style=&quot;border:2px solid DodgerBlue;&quot;&gt;Hello World&lt;/h1&gt;&lt;h1 style=&quot;border:2px solid Violet;&quot;&gt;Hello World&lt;/h1&gt; 颜色值 使用RGB值、HEX值、HSL值、RGBA值或者HSLA值来指定颜色。 123456&lt;h1 style=&quot;background-color:rgb(255, 99, 71);&quot;&gt;...&lt;/h1&gt;&lt;h1 style=&quot;background-color:#ff6347;&quot;&gt;...&lt;/h1&gt;&lt;h1 style=&quot;background-color:hsl(9, 100%, 64%);&quot;&gt;...&lt;/h1&gt;&lt;h1 style=&quot;background-color:rgba(255, 99, 71, 0.5);&quot;&gt;...&lt;/h1&gt;&lt;h1 style=&quot;background-color:hsla(9, 100%, 64%, 0.5);&quot;&gt;...&lt;/h1&gt; 直接使用RGB：rgb(red, green, blue) 使用RGBA：有不透明度的RGB 背景12345678910111213body &#123; background-color: lightblue;/* 背景色 */ opacity: 0.3;/* 不透明度 */ background-image: url(&quot;paper.gif&quot;);/* 背景图像 */&#125;/* 以及 */body &#123; background-image: url(&quot;tree.png&quot;); background-repeat: no-repeat; background-position: right top; background-attachment: fixed;&#125; 简写： 123body &#123; background: #ffffff url(&quot;tree.png&quot;) no-repeat right top;&#125; 在使用简写属性时，属性值的顺序为： background-color background-image background-repeat background-attachment background-position 轮廓（不同于边框）CSS 拥有如下轮廓属性： outline-style outline-color outline-width outline-offset outline 文本 文本对齐 文本方向 垂直对齐 文字装饰 大小写自动转换 缩进 字符间距 行高 字间距 文字阴影 斜体 粗细 大小 CSS 盒子模型CSS 选择器布局方式CSS3","categories":[],"tags":[{"name":"笔记","slug":"笔记","permalink":"http://petertan303.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"未完待续","slug":"未完待续","permalink":"http://petertan303.github.io/tags/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/"}]},{"title":"2023年1月20日","slug":"2023年1月20日","date":"2023-01-20T03:42:26.000Z","updated":"2023-01-20T11:36:58.811Z","comments":true,"path":"2023/01/20/2023年1月20日/","link":"","permalink":"http://petertan303.github.io/2023/01/20/2023%E5%B9%B41%E6%9C%8820%E6%97%A5/","excerpt":"","text":"关于阿里云ESC的应用本质是一个可租赁服务器。要用于搭建博客，需要安装Apache（服务器软件）、MariaDB数据库（或者MySql）、PHP，然后通过WordPress完成博客的搭建。 CSS的学习笔记 测试html元素的插入hhhhh 12&lt;p&gt;&lt;b&gt;hhhhh&lt;/b&gt;&lt;/p&gt;","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://petertan303.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"总结一下hexo-theme-fluid的使用方法","slug":"总结一下hexo-theme-fluid的使用方法","date":"2023-01-17T02:16:35.000Z","updated":"2023-01-17T03:32:21.729Z","comments":true,"path":"2023/01/17/总结一下hexo-theme-fluid的使用方法/","link":"","permalink":"http://petertan303.github.io/2023/01/17/%E6%80%BB%E7%BB%93%E4%B8%80%E4%B8%8Bhexo-theme-fluid%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","excerpt":"来看看罢？","text":"全局 设置文章默认封面：12post: default_index_img: /img/example.jpg 代码块设置：123456789101112code: copy_btn: true highlight: enable: true line_number: true lib: &quot;highlightjs&quot; highlightjs: style: &#x27;Github Gist&#x27; bg_color: false prismjs: style: &quot;default&quot; preprocess: true copy_btn: 是否开启复制代码的按钮 line_number: 是否开启行号 highlight: 是否开启代码高亮 lib: 选择生成高亮的库，可选项: highlightjs、prismjs，对应下面两组配置，高亮的配置说明具体见主题配置中的注释 首页 大标题：Slogan(打字机)，配置方法是1234index: slogan: enable: true text: 这是一条 Slogan 每篇文章 指定摘要：12# 在文章开头加上：excerpt: 这是摘要 隐藏文章：12# 在文章开头加上：hide: true 手动置顶：12# 在文章开头加上：sticky: 100 在首页的封面：12# 在文章开头加上：index_img: /img/example.jpg 文章头图：12# 在文章开头加上：banner_img: /img/post_banner.jpg 手动置顶：12# 在文章开头加上：sticky: 100 勾选框：1&#123;% cb 文字, 是否已勾选, 是否内联 %&#125; 这是一个勾选框 按钮：1&#123;% btn 链接, text, title %&#125; text 组图：1234567&#123;% gi total n1-n2-... %&#125; ![](url) ![](url) ![](url) ![](url) ![](url)&#123;% endgi %&#125; 特殊页面 About 页","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://petertan303.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"Hello World？Peter Tan！！","slug":"hello-world","date":"2023-01-16T13:39:17.273Z","updated":"2023-01-16T13:39:17.273Z","comments":true,"path":"2023/01/16/hello-world/","link":"","permalink":"http://petertan303.github.io/2023/01/16/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]},{"title":"我超，原","slug":"图片测试","date":"2023-01-16T12:19:36.000Z","updated":"2023-01-17T06:39:12.948Z","comments":true,"path":"2023/01/16/图片测试/","link":"","permalink":"http://petertan303.github.io/2023/01/16/%E5%9B%BE%E7%89%87%E6%B5%8B%E8%AF%95/","excerpt":"测试一下添加图片！！","text":"图片测试……？能看见吗？ 实际操作时，hexo 会给文件夹套进一串文件夹嵌套，比如说今天是2023年1月16日，套完前面会多一个2023&#x2F;01&#x2F;16&#x2F; 操作方法： 安装插件 hexo-asset-imageconfig 里的 post_asset_folder 改为 ture然后新生成的 md 就有了伴生图片文件夹，把图片放进去要使用的话，日期 + 文件夹 + 文件名例如：![图片](2023/01/16/图片测试/83-2.jpg &quot;&quot;) 有了插件 hexo-renderer-marked 的话，可以直接用图片名字，不需要日期和文件夹。 官方方法不使用中括号小括号的 md 语法，而是使用官方的 &#123;% asset_img example.jpg This is an example image %&#125; 现在使用了fluid主题放在source底下的img文件夹会被一并导出，使用img内图片：&#x2F;img&#x2F;asdasd.jpg 然后，事实证明，现在不能直接用图片名字了。 综上，要使用图片，就放在 source&#x2F;img&#x2F; 下，使用的时候引用 ![](img/图片 &quot;&quot;)，要想并排显示需要套一个 &#123;% gi 4 4 %&#125;` 和 `&#123;% endgi %&#125;。&#123;% asset_img example.jpg This is an example image %&#125; 似乎不能用了。 这是按钮NGA!!","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://petertan303.github.io/tags/test/"}]},{"title":"2022年10月17日","slug":"2022年10月17日","date":"2023-01-16T09:29:47.000Z","updated":"2023-01-16T10:10:08.920Z","comments":true,"path":"2023/01/16/2022年10月17日/","link":"","permalink":"http://petertan303.github.io/2023/01/16/2022%E5%B9%B410%E6%9C%8817%E6%97%A5/","excerpt":"","text":"20点28分：之前看nga，现在看x岛，看疯了。傻逼。 摸了一晚上🐟，一开始打算做大物雨课堂，但并没有做。想做数据结构，也没有。刚刚发现大物雨课堂已经在十六号晚上截止了。我，傻逼。 六天前开始玩碧蓝航线。肝度很大，代理不稳定等等，任务多，这两天少了，但是为了配队还是在看它资料。 看了一会儿博客相关。typechowordpresshexo比较底层点：mysqlgitlab apipost：做apipostman 买域名（阿里云即可）远程空间（虚拟&#x2F;服务器&#x2F;借的）安装网站（上传网站安装包）“宝塔面板” 安了个node.js，真的小。npm 是 Node.js 的包管理工具，用来安装各种 Node.js 的扩展。据说git是为linux准备的。难怪，win下教程少。发现notepad++不能被识别为默认程序。傻逼。 Xshell是一款功能强大的终端模拟器，支持SSH1，SSH2，SFTP，TELNET，RLOGIN和SERIAL。xshell可以远程连接Linux的ssh客户端，也就是“ssh客户机”（但是收费啊） multipass的ubuntu虚拟机不会用。上次瞎搞了想改远程源，结果妈的没成功偷鸡不成蚀把米。卑微。现在的状态似乎是能联网不能安装包。 之前的ai绘画，特别为了他安了包，但是下torch似乎py只能用它附带的那个版本，而那个版本没装torch，下载起来慢的离谱。找个机会安了。 感觉很几把炫酷、甚至可以尝试的东西：1、ai绘画2、博客：域名挺便宜。顶多十年八百。3、附带的，linux下的一堆操作4、qt，c的被我卸掉了，还有pyqt可以用5、哦，还要很久之前，阿米娅机器人，基于啥来着 opengl：一个图形库，api， 博客园好几把炫酷啊 我在unity里面有个node.js？？ps里面也有一个？？xmind也有？？vs里面也有，好家伙但是新安装的有个shell界面。 condaanacondapycmdpip 廖雪峰的官方网站菜鸟教程qt还有个开源社区看雪-逆向工程社区 差点忘了我还在学c++ 妈的，别忘了作业傻逼大物这是第二次错过了别忘了数字逻辑电路！！！ cnss他们好他妈牛逼啊全是不眠不休的卷王吗！还有立人班！！被请求然后说两点开始干活？？是人？ cf（codeforce）和leetcode multipass的使用：Usage: multipass [options] 用法：multipass 加 命令Create, control and connect to Ubuntu instances.操作 ubuntu 实例。 This is a command line utility for multipass, a service that manages Ubuntu instances.multipass 命令行 Options: -?, -h, –help Displays help on commandline options. 帮助 –help-all Displays help including Qt specific options. 有qt的帮助 -v, –verbose Increase logging verbosity. Repeat the ‘v’ in the short option for more detail. Maximum verbosity is obtained with 4 (or more) v’s, i.e. -vvvv.不知道是什么 Available commands: alias Create an alias 创建别名（备注） aliases List available aliases 列出别名 authenticate Authenticate client 证实客户？ delete Delete instances 删掉实例 exec Run a command on an instance 在实例上跑命令 find Display available images to create instances from 显示可用图像以从中创建实例？ get Get a configuration setting 获取配置设置 help Display help about a command 单个命令的help info Display information about instances 实例信息 launch Create and start an Ubuntu instance 创建实例 list List all available instances 列出实例 mount Mount a local directory in the instance 在实例中装载本地目录？ networks List available network interfaces 列出可用网络接口 purge Purge all deleted instances permanently 永久清除所有实例 recover Recover deleted instances 恢复被删除的实例 restart Restart instances 重启实例 set Set a configuration setting 设实例信息 shell Open a shell on a running instance 开一个shell start Start instances 开始实例 stop Stop running instances 停止实例 suspend Suspend running instances 暂停实例 transfer Transfer files between the host and instances 在主机和实例之间传文件（！！！！） umount Unmount a directory from an instance 在实例中卸载本地目录？ unalias Remove an alias 移除别名 version Show version details 显示版本 总结： 操作别名 删除停止暂停启动创建重启实例 在主机实例之间传文件 multipass本身相关","categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://petertan303.github.io/tags/%E6%97%A5%E5%BF%97/"}]},{"title":"2023年1月16日","slug":"2023年1月16日","date":"2023-01-16T09:28:49.000Z","updated":"2023-01-16T13:39:12.077Z","comments":true,"path":"2023/01/16/2023年1月16日/","link":"","permalink":"http://petertan303.github.io/2023/01/16/2023%E5%B9%B41%E6%9C%8816%E6%97%A5/","excerpt":"","text":"hexo 使用： 12345678$ cd myblog//首先进入myblog文件夹$ hexo clear//然后清理之前残留的网页$ hexo g//然后生成网页$ hexo d //然后推送到GitHub上 markdown 本身使用 标题：井号，或 “ &#x3D;&#x3D;&#x3D; ” ， 或 “ — ” 段落：一行空白行，不应使用 tab 或者空格。 换行：段尾加两个空格，并换行。或者使用 标签。 粗体：两个星号或者两个下划线。 斜体：一个星号或一个下划线。 引用：在段落前添加 &gt; 符号。要引用多个段落，应给空白行也添加 &gt; 符号。 嵌套引用：额外加一个 &gt; 符号。 列表：数字和英文句号。 例如： 阿三大苏打 阿三大苏打 阿三大苏打 无序列表：段前加 - 或 * 或 + 。要保持缩进，需要添加四个空格，或一个 tab 。 代码块：四个空格或一个 tab 。 短单词表示为代码：用 ‘ 包裹。一段代码包含单引号：这段代码应用 &#96;&#96; 包裹。围栏代码块：加入 &#96;&#96;&#96; 包裹。 分割线： 三个星号、三个 - 、三个下划线，并在此之后添加空白行。 链接：中括号包含文本，小括号包含链接。所谓 title ， 即是鼠标悬浮在链接上的时候显示的东西，可以用双引号写在小括号结尾。hhh对于一般的链接，用尖括号框起来即可。https://nga.178.com 图片：![这是图片](/assets/img/philly-magic-garden.jpg &quot;Magic Gardens&quot;) 或者有链接的图片：[![沙漠中的岩石图片](/assets/img/shiprock.jpg &quot;Shi prock&quot;)](https://markdown.com.cn) 如何将 Windows 下文件导入 wsl wsl 中的 &#x2F;mnt 文件夹，对应 Windows 的计算机。例如，想要引用 D:\\桌面\\临时 里面的 103041518_p0.jpg，对应过来就是 &#x2F;mnt&#x2F;d&#x2F;桌面&#x2F;临时&#x2F;103041518_p0.jpg然后复制到 wsl：cp &#x2F;mnt&#x2F;d&#x2F;桌面&#x2F;临时&#x2F;103041518_p0.jpg ~&#x2F;myblog&#x2F;source&#x2F;_posts&#x2F;图片测试 看看效果？ Git 的使用 git commit &lt;文件&gt; （然后需要写提交日志） git pull git push","categories":[],"tags":[]},{"title":"my first blog test?","slug":"博客测试1","date":"2023-01-16T05:30:02.000Z","updated":"2023-01-16T09:51:09.351Z","comments":true,"path":"2023/01/16/博客测试1/","link":"","permalink":"http://petertan303.github.io/2023/01/16/%E5%8D%9A%E5%AE%A2%E6%B5%8B%E8%AF%951/","excerpt":"","text":"Hello, world! 1//这是一个代码块 标题网址测试：nga","categories":[],"tags":[{"name":"test","slug":"test","permalink":"http://petertan303.github.io/tags/test/"}]}],"categories":[],"tags":[{"name":"日志","slug":"日志","permalink":"http://petertan303.github.io/tags/%E6%97%A5%E5%BF%97/"},{"name":"Test","slug":"Test","permalink":"http://petertan303.github.io/tags/Test/"},{"name":"笔记","slug":"笔记","permalink":"http://petertan303.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"未完待续","slug":"未完待续","permalink":"http://petertan303.github.io/tags/%E6%9C%AA%E5%AE%8C%E5%BE%85%E7%BB%AD/"},{"name":"test","slug":"test","permalink":"http://petertan303.github.io/tags/test/"}]}